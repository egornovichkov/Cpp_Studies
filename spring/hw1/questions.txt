1.  Преимущества сырых указателей над умными существенны, но все же при прочих равных рекомендуется использовать умные указатели.

    1.1. В случае когда от указателя не требуется владение ресурсом, стоит использовать сырые указатели, ведь все умные указатели "заключают контракт" на
    владение ресурсом и их использование может приводить к ненужным усложнениям или ошибкам.

    1.2. Некоторые функции языка и библиотек C++ могут принимать только сырые указатели в качестве параметров. В некоторых случаях может возникнуть идея 
    динамически выделить умный указатель, но это считается крайне плохой практикой в виду возможных утечек памяти.

    1.3. Размер
        unique_ptr имеет такой же размер как и сырой указатель, однако shared_ptr и weak_ptr в большинство реализаций компилятора в два раза "тяжелее", чем
        сырой указатель, т.к. содержат еще и указатель на блок управления. 

    1.4. Скорость работы
        Методы работы с указателями, как я понимаю, немного быстрее, чем методы работы с умными указателями в виду того, что умным указателям необходимо
        реализовывать некоторую доп. логику, хотя я уверен, что работа с умными указателя оптимизирована и для выполнения тех же действий с сырыми указателями
        неопытный программист может написать и более медленный код. Однако при передаче кастомных удалителей/распределителей в умный указатель при его создании 
        требуется скопировать удалитель/распределитель. Работа с shared_ptr может проходить медленнее в виду инкремента/декремента счетчиков, а, учитывая 
        необходимость атомарности этих операций, замедление еще сильнее.

2.  Если бы контрольный блок был частью std::shared_ptr, для каждого shared_ptr существовал бы свой контрольный блок, т.е. их счетчики были бы независимы друг 
от друга. При удалении одного из таких указателей его счетчик бы обнулялся и ресурс освобождался. Если в группе совместных указателей больше 1, то при 
удалении еще одного указателя, ресурс бы освобождался заново, что приводило бы к UB.

3.  Счетчик слабых ссылок в контрольном блоке std::shared_ptr показывает количество std::weak_ptr, указывающих на ресурс, которым владеет std::shared_ptr.
Для ответа на вопрос необходимо определить назначение слабых указателей: они позволяют отслеживать состояние ресурса, которым владеет std::shared_ptr без
непосредственного владения, а также могут создавать новые std::shared_ptr для совместного владения ресурсом. Таким образом есть 2 сценария для которых
полезен слабый счетчик:

    3.1. Счетчик > 0, Слабый счетчик > 0
        Существуют слабые указатели, которые могут отслеживать состояние ресурса, а также создавать новые std::shared_ptr

    3.2. Счетчик = 0, Слабый счетчик > 0
        Ресурс освобождается, т.к. как было сказано слабые указатели не управляют ресурсом, однако контрольный блок существует до тех пор, пока слабый счетчик 
        не станет нулевым. Создание shared_ptr'ов при помощи weak_ptr'ов невозможно. Единственным плюсом такого сценария является возможность узнать состояние 
        ресурса (освобожден или нет) при помощи функций-членов слабого указателя.

4.  Использование метода get() небезопасно, но объяснимо (Например для передачи в функцию, которая не принимает умный указатель). Опасность использования
этого метода заключается в нарушении логики работы умных указателей. Функция внутри которой был вызван метод get() получает управление над ресурсом, что
нарушает контракт между умным указателем и ресурсом (Например эта функция может освободить ресурс, затем умный указатель - получаем UB). 

5.  std::unique_ptr нельзя копировать в связи с тем, что при копировании объекта этого класса в другой объект копируется поле, содержащее указатель на ресурс. 
Это является нарушением контракта между ресурсом и обоими объектами, ведь каждый из них управляет ресурсом, что недопустимо по логике работы unique_ptr
(Например один из объектов может освободить ресурс, затем второй - получаем UB).
1.  Если тип параметра не ссылочный, то объект передается по значению, что означает создание его копии. Таким образом при выполнении логики в теле функции,
она будет применяться к копии объекта, а не к нему самому, т.е. сам объект останется неизменным (константность не нарушается). Тогда компилятору проще 
не навешивать дополнительный спецификатор константности при выводе типа шаблона, ведь он не влияет на поведение функции.

2.  Функцию std::size можно применять к массиву переданному по ссылке и нельзя применять к массиву переданному по указателю. Связано это с тем, что при 
передаче массива по указателю тип "массив" преобразуется в указатель на первый элемент этого массива, т.е. теряется информация о размере массива.
Если говорить более формально, то шаблонная функция std::size реализована следующим образом:
template<class C>
constexpr auto size(const C& c) -> decltype(c.size())
{
    return c.size();
}
и также имеет специализированную версию
template<class T, std::size_t N>
constexpr std::size_t size(const T (&array)[N]) noexcept
{
    return N;
}
Таким образом ни к одному из этих шаблонов не подходит тип указателя T*, у std::size просто нет подходящей реализации. Более того тип T* не хранит никакой
информации о размере массива, т.е. в случае если массив был передан не по ссылке, информация о его размере теряется.
В случае передачи по указателю существует специализация шаблона функции std::size, возвращающая размер массива, т.е. при передаче по ссылке информация о
размере массива сохраняется и можно получить его размер при помощи std::size.

3.  Согласно С. Мейерсу прямая передача делает возможным написание шаблонов функций, которые принимают произвольные аргументы и передают их другим функциям 
так, что целевые функции получают в точности те же аргументы, что и переданные исходным функциям.

Таким образом, концепция идеальной передачи (perfect forwarding) сформулирована для случаев, в которых необходимо перенести полную и точную информацию о типе
передаваемых объектов. Используется в тех случаях, когда от функций требуется оставлять неизменными фундаментальные свойства своих аргументов, то есть:
константный объект должен передаваться как немодифицируемый объект.
модифицируемый объект должен оставаться модифицируемым.
перемещаемый объект должен оставаться перемещаемым.
Также, можно добавить, что концепция идеальной передачи позволяет удобно писать полностью прозрачную обертку для функции (обертку, сохраняющую свойсвта  
аргументов, передаваемых в целевую функции и не создающую временных переменных)

4.  В отличие от std::move, std::forward условно приводит тип аргумента к rvalue-ссылке (условием является: тип параметра шаблона Т является rvalue-ссылкой
или не является ссылочным типом), std::move же безусловно приводит тип аргумента к rvalue-ссылке. Таким образом в случае использования std::move вместо
std::forward при реализации передачи будет нарушена суть идеальной передачи: если мы передадим lvalue-ссылку как аргумент для оболочки над функцией, 
функция вызовется от аргументов std::move(arg1), std::move(arg2), etc., т.е. информация о типе передаваемых аргументов искажается, что противоречит
концепции идеальной передачи.

5.  Идеальная передача работает при помощи механизмов универсальных ссылок и свертки ссылок. Первый механизм позволяет компилятору использовать особые
правила вывода типа параметра шаблона, а второй позволяет выводить тип, в котором содержится комбинация двух ссылок и определяет правила вывода типа в этом
случае. Эти две механики используются при реализации функции std::forward, благодаря которой и сохраняется категория выражения переданного, например, в 
обертку функции.
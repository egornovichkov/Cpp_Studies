1.  Вариативные шаблоны удобно использовать в случаях, когда необходимо применить некоторую логику к набору переменных произвольной длины.
Примером может служить функция print, в случае если захочется реализовать ее так как она реализована в C/Python использование вариативных шаблонов будет
изящным и простым решением. Также в пример можно привести функции max/min, можно написать свою функцию my_to_string, которая будет принимать произвольное
количество переменных, переводить их в строки и конкатенировать их (один раз лично мне пригодилась бы такая функция), можно реализовать аналог питоновской
функции map (первым аргументом принимает функцию, далее принимает набор переменных произвольной длины и применяет эту функцию к каждой переменной из 
набора). Касаемо применения вариативных шаблонов классов: можно реализовать контейнер, хранящий однотипные/неоднотипные переменные, поддерживающий
написанную программистом логику (уже есть контейнеры STL, но в случае если необходимо реализовать какую-то необычную логику - вариативные шаблоны это
решение).

2.  Для поочередной обработки всех аргументов из пакета аргументов функции можно использовать рекурсию (алгоритм следующий: создаем шаблон функции с 1 
шаблонным параметром, а также создаем вариативный шаблон с параметрами <typename First, typename... Pack> для этой же функции. В теле функции обрабатываем 
первый аргумент, а далее вызываем эту же функцию, но уже передаем в нее только аргументы, имеющие типы из пачки Pack), можно использовать выражения свертки
для поочередного применения некоторых операторов к каждому "элементу" из пачки аргументов функции.

3.  Для вычисления количества параметров в пакете параметров вариативного шаблона используется оператор sizeof...()

4.  Выражения свертки могут быть унарными и бинарными, а также левым и правыми: унарным выражением свертки является выражение, содержащее оператор, 
нераскрытую пачку параметров и эллипсис. В зависимости от того где расположен эллипсис унарные выражения свертки различают на левое и правое, раскрываются
они также по разным правилам: (pack op … )  →  pack[0] op (pack[1] op (pack[2] op … ( … pack[N]))) - правое унарное выражение свертки,
( … op pack ) → ((((pack[0] op pack[1]) op pack[2]) op pack[3]) op … pack[N]) - левое. В бинарном выражении свертки содержится дополнительно еще один 
операнд, который не является пачкой параметров. Их также разделяют на левые и правые. 
(pack op ... op expr) —> (pack[0] op (pack[1] op (pack[2] ... (pack[N] op expr)))) - правое бинарное выражение свертки
(expr op ... op pack) —> ((((expr op pack[0]) op pack[1]) op pack[2]) ... op pack[N]) - левое бинарное выражение свертки
Выражения свертки применяются для выполнения некоторой логики с каждым из "элементов" пачки поочередно, т.е. дают удобную альтернативу рекурсии и другим
методам для выполнения некоторой логики с, например, аргументами функции вариативного шаблона.

5.  Разница между статическим и динамическим полиморфизм в языке c++ заключается в том, в какой конкретно момент происходит связывание реализации сущности с 
её "вызовом". При статическом полиморфизме связывание происходит во время компиляции, при динамическом же полиморфизме связывание происходит в рантайме. 

Другими словами:
Полиморфизм - предоставление единого интерфейса для сущностей разных типов, при этом статический полиморфизм
предоставляет интерфейс во время компиляции программы, а динамический полиморфизм предоставляет этот интерфейс во время выполнения программы.

Например, для функции разница между статическим и динамическим полиморфизмом заключается в том когда происходит связывание реализации функции с вызовом функции: 
во время компиляции или во время выполнения программы. Таким образом перегрузка функции или использование шаблона есть статический полиморфизм. Проявлением же
динамического полиморфизма является механизм виртуальных функций при наследовании.
1. "С++ — компилируемый мультипарадигменный язык программирования со строгой статической типизацией, поддерживающий 
высокоуровневые и низкоуровневые возможности"
Объясню своими словами как я понимаю каждое слово. Компилируемый язык программирования означает, что каждая строка кода
последовательно преобразуется в машинный код при помощи программы, называемой компилятором. Мультипарадигменный означает, что
язык поддерживает разные парадигмы программирования, т.е. различные подходы к программированию. Строго статическая типизация
означает, что после объявления типа переменной его нельзя изменить. Поддерживающий высокоуровневые и низкоуровневые возможности
означает, что с++ поддерживает как далекие, так и близкие к железу концепции.

2. Фундаментальные типы
    а. bool
        Занимает 1 байт (не 1 бит, т.к. компьютер не может обращаться к конкретному биту), принимает значение 0 (false) или 1(true), 
        поддерживает логические операции ||(логическое или), && (лог. и), !(лог. отрицание). Если некоторое выражение, 
        например a || b, заведомо правдивое (a = 1), то значение b не проверяется (вычисления Маккарти)
    b. char
        Символьный литерал. Занимает 1 байт. Существуют также и другие символьные литералы, такие как char8_t(может содержать любые
        графические символы, за исключением двойных кавычек ("), обратной косой черты (\) или символа новой строки, его значение
        хранится в формате u8"a" в кодировке UTF8), char16_t и char32_t (занимают 2 и 4 байта соответственно,
        тоже самое, что и char8_t, только содержат символы в кодировках UTF16 и UTF32 соответственно, пишутся в форматах u"a" и U"a"),
        wchar_t (1 байт, пишется в формате L"a", судя по всему в разных компиляторах кодируется разными кодировками).
        Переменная типа char интерпретируется как ASCII-символ. ASCII - таблица из 128 символов, соответствующих числам от 0 до 127.
        В языке C++ есть управляющие символы. Они начинаются с бэкслеша (\), а затем следует определенная буква или цифра. 
        \n - символ новой строки, \t - большой отступ, \? - вставка знака вопроса и т.д.
    c. int short long
        Целочисленные типы данных. в с++ есть следующие целочисленные типы: 
            1. знаковые 
                int (занимает 4 байта), short (2 байта), long (4 байта), long long (8 байт)
            2. беззнаковые
                unsigned int, unsigned short, etc
        Модуль беззнаковых целочисленных типов данных больше, однако при попытке присвоить такому типу данных отрицательное значение
        возникнут проблемы (из-за того, что знак хранится в первом бите, т.е. 0 или 1 и отрицательные беззнаковые числа хранятся неверно)
        Размер некоторых целочисленных типов данных может различаться в зависимости от компилятора.
    d. float/double
        Типы данных с плавающей точкой. float занимает 4 байта (от 3,4e-38 до 3,4e-38 с точностью 7 знаков), double (от 1,7e-308 до 1,7e-308 с 
        точностью 15 знаков). Их можно записывать в научном формате (3.23e-11)
    e. void
        Отсутствие любого типа. Используется для того, чтобы показать, что функция не возвращает значение или указать, что функция не
        имеет аргументов (устаревшее использование, перешло из C)

3.  В C++ существует проблема переносимости, в связи с тем, что для разных архитектур и ОС разные компиляторы. Проблемы могут возникать,
    например, с размером стандартных типов данных вроде целочисленных long или символьных wchar_t или при использовании расширений
    стандартной библиотеки, предоставляемых разработчиком компилятора. Как говорят ответы на стаковерфлоу, для написания 
    кроссплатформенного кода нужно тестировать код в разных компиляторах, не использовать расширения стандартной библиотеки, 
    предоставляемых разработчиком компилятора, избегать прямых вызовов ОС.

4.  Объявление - информирование компилятора о том, что объявленное имя будет использовано в коде далее (под него будет выделена память). 
Можно объявлять переменную несколько раз в разных блоках кода. Определение - предоставление информации о типе объявленного имени
(тип данных переменной, описание функции, класса и т.п. То есть для переменной - выделение памяти). Связывание имени с памятью
начинается на этапе компоновки. Инициализация - определение и объявление объединяют с присваиванием начального значения.
Присваивание - присваивание значения уже определенной переменной.

5. Процессоры считывают данные не по 1 байту, а по 2, 4, 8, 16 или 32 байта, размер таких блоков называется гранулярностью. Пусть некоторый
адрес сохранен начиная не с первой ячейки памяти. Например рассмотрим два регистра по 4 байта с адресов 0 и 1. Тогда процессору с
гранулярностью в 1 байт потребуется 4 операции для обоих случаев, т.е. по 4 обращения к памяти в обоих случаях. Однако, процессору с
гранулярностью в 2 байта потребуется всего 2 обращения к памяти для случая с адресом 2, что происходит быстрее, чем в прошлом случае, т.е.
увеличивает производительность процессора. Однако проблемы начинаются при считывании данных с адреса 1. Процессору придется выполнить 
лишнюю работу, считав 6 байт вместо 4 из-за того, что адрес не кратен гранулярности. Очевидно это замедляет работу процессора,
а в некоторых случаях, процессор не обрабатывает такие данные вовсе. Если же данные выравнивать, размещая их по границе гранулярности,
потребуется меньше обращений к памяти и меньше операций с данными, что приведет к более высокой производительности.

	
1.  Процесс развертывания стека при выбросе исключения происходит следующим образом: первым шагом компилятор пытается найти инструкции для обработки
исключения в функции, выбросившей исключение. Если компилятор находит catch-блок с подходящим типом аргумента, то этот блок обрабатывает исключение и
программа продолжает работу. В случае если такого catch-блока в теле этой функции нет, компилятор переходит на уровень вложенности выше, т.е.
к функции в теле которой была вызвана функция, выбросившая исключение в попытке обработать это исключение. Таким образом компилятор последовательно
проходит по всей цепочке вложенных вызовов. Финально возможны две ситуации: компилятор обрабатывает исключение (нормальная ситуация), либо компилятор 
в развертывании стека доходит до конца main, так и не обработав исключение. Во втором случае будет вызвана функция std::terminate, которая в свою очередь 
по дефолту вызывает функцию abort. Функция abort аварийно завершает программу и является индикатором некорректной работы программы. Стоит также отметить,
что при развертывании стека прекращают существовать локальные переменные, объявленные в составных инструкциях и определениях функций, из которых произошел 
выход. Стандарт языка гарантирует, что во время описанного процесса вызываются деструкторы локальных объектов классов.

2.  Механизм использования кодов возврата имеет следующие недостатки:
    2.1. Неоднозначность - пусть функция возвращает int или double, в таком случае не получится отличить код возврата от нормального значения, возвращенного
    функцией.

    2.2. Для разных возвращаемых типов функции придется придумывать свои коды возврата, что неудобно и неуниверсально, приходится использовать union / 
    std::variant или передавать в функцию код возврата доп. аргументом типа ссылки.

    2.3. Логика с кодами возврата прописана в теле функции и, более того, блоки с этой логикой могут содержаться внутри других блоков функции, описывающих
    ее нормальное поведение. Таким образом, функцию становится труднее читать из-за доп. логики по обработке ненормальных ситуаций.

    2.4. Коды возврата по очевидным причинам не применимы в конструкторах, деструкторах и операторах.

3.  Особенности механизма исключений
    3.1. Многоуровневость
    Как было описано в КВ1 раскрутка стека является одним из полезным свойств исключений, в случае если исключение не было обработано в одной функции,
    компилятор переходит на уровень выше по дереву вызова функций для обработки исключения

    3.2. Эффективность
    В случае если исключение не было выброшено, на выполнение программы практически не тратятся доп. расходы на их обработку (Однако вопрос использования 
    исключений в коде является дискуссионным в виду того, что при выбросе исключения ресурсы все же тратятся)

    3.3. Преобразования (иерархия исключений)
    В стандартной библиотеке уже существует довольно обширная иерархия классов исключений, реализованная при помощи механизма наследования. Как стало
    понятно из предыдущего семинара такие иерархии удобны в использовании в связи с тем, что к любому из классов иерархии можно обращаться по 
    указателю/ссылке на базовый класс исключения. Также иерархию классов исключений можно дополнить своими, что также является удобным инструментом
    для обработки ошибок.

4.  Спецификатор noexcept говорит компилятору о том, что функция не будет выбрасывать исключения. В случае если noexcept функция выбросит исключение 
сработает std::terminate и программа завершится аварийно. Использование noexcept полезно в случае если программист может гарантировать, что функция не 
генерирует исключений. В случае noexcept функций компилятор отпимизирует генерируемый ассемблерный код. Использование noexcept рекомендуется в деструкторах
(т.к. деструктор не должен выбрасывать исключения, это приведет к неоднозначности) и конструкторах перемещения (полезно в одной ситуации: пусть есть 
пользовательский класс, из экземпляров которого составляется некоторый контейнер std, например std::vector. В какой-то момент вместимости вектора перестает 
хватать и вектор выделяет новую память с запасом и переносит туда содержимое старого фрагмента памяти. Если перемещающий конструктор не отмечен noexcept 
спецификатором, то вместо него вектор вызовет конструктор копирования, хотя перемещающий в этом случае более желаем. Связано это с тем, что все контейнеры
std представляют базовую гарантию безопасности и должны сохранить свое состояние вектора в случае вылета исключения)

5.  Если в списке инициализации конструктора будет выброшено исключение, то его обработка будет делегирована функции в которой конструктор был вызван.
При этом деструктор объекта не будет вызван т.к. фактически объект класса не был создан. Будут очищены поля, проинициализированные до поля, которое
выбросило исключение, причем в порядке обратном порядку инициализации. Если возникает необходимость обработать это исключение в самом конструкторе класса,
необходимо использовать функциональный try-блок. При использовании функциональных try-блоков вы должны либо выбросить новое исключение, либо повторно 
сгенерировать пойманное исключение. Если вы это не сделаете, то пойманное исключение будет повторно сгенерировано и стек начнет раскручиваться. Синтаксис
функциональных try-блоков выглядит следующим образом:
A::A()
try : init1(), ..., initn()
{
  // Constructor
}
catch(...)
{
  // Handle exception
  // throw something or throw
}
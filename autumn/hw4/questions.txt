1.  Значения данных-членов структуры в С++ можно задать при помощи следующих способов: 
    -   Объявление данных-членов в теле структуры и последующее присваивание им значений в теле конструктора
    -   Инициализация в списке инициализации членов конструктора
    -   Задание значений по умолчанию при объявлении в теле структуры
Первый способ не эффективен, лучше инициализировать переменные, а не присваивать им значение (более того таким способом не получится работать с ссылками)

2.  Списки инициализации позволяют инициализировать данные-члены run-time значениями (безусловно можно сделать это и при помощи присваивания в теле
конструктора, однако такой подход не сработает если данные-члены, например, ссылочного или константного типа)

3.  Для начала, суть идиомы RAII заключается в том, что получение некоторого ресурса происходит вместе с инициализацией, а освобождение этого ресурса с
уничтожением. Реализация идиомы RAII при помощи конструктора и деструктора такова: при работе с некоторым ресурсом, например с файлом, следует "обернуть" его
в объект структуры. Тогда открытие файла соответствует инициализации объекта структуры в ее конструкторе, а закрытие файла - уничтожению объекта в
деструкторе

4.  Использование битовых полей и объединений позволяет программе более эффективно тратить ресурс устройства поэтому битовые поля и объединения стоит 
рассматривать при написании программ для устройств с малым объемом памяти, например, микроконтроллеров или для оптимизации работы программы (что редко, т.к.
современные компьютеры обладают большим запасом памяти)

5.  Перечисления с областью видимости задаются при помощи ключевого слова class после enum. Их особенностью является ограниченная область видимости
(константы блока enum class видны только в блоке enum class). Для обращения к константам перечисления в другом блоке нужно обратиться к константе
при помощи синтаксиса enum_name::const1. Рекомендуется использовать именно перечисления с областью видимости из соображения "Не сравнить красное с мягким".
Константы разных перечислений с областью видимости имеют разные типы и компилятор выдаст ошибку. Таким образом можно более грамотно писать код и не допускать
трудно отлаживаемых ошибок (сравнения констант двух разных обычных перечислений допускается, при этом, скорее всего не имеет смысла)
1.  Шаблоны в c++ - это "трафареты" для создания сущностей, некоторые, или все типы данных которых не указаны на момент создания шаблона. 
Существует четыре разновидности шаблонов: шаблоны функций, классов, псевдонимов типов и переменных. Шаблоны объявляются ключевым словом template, после 
которого нужно указать так называемые параметры шаблона (типы данных, которые потом будут подставлены в шаблон) в треугольных скобках, используя
ключевое слово typename или class, либо non-type параметр. При вызове шаблона (т.н. инстанцировании), компилятор использует «трафарет» в качестве образца, 
заменяя тип параметра шаблона на фактический тип переменных, передаваемых в сущность.

2.  Двухэтапная трансляция шаблона осуществляется следующим образом: тело шаблона проверяется на наличие "общих" ошибок (синтаксических ошибок, некоторых
логических ошибок, например, вызов несуществующей функции), далее компилятор пытается произвести инстанцирование шаблона, то есть подставить тип данных в
параметр шаблона и, в случае успеха, запускается процесс компиляции со сгенерированной конкретной шаблонной сущностью (функцией, классом и т.д.).

3.  Надо отметить, что для шаблонов функций не существует частичной специализации, для шаблонов функций применяется так называемся перегрузка шаблона функции 
(шаблон функции некоторым образом конкретизируется, например для шаблона 
template <typename T> T func(const T& x, const T& y){}
шаблон 
template <typename T> const std::vector<T>& func(const std::vector<T>& v1, const std::vector<T>& v2){} 
будет перегрузкой). 
Постараюсь описать свое представление об алгоритме выбора функции компилятором при ее вызове. При разрешении перегрузки сначала рассматриваются
нешаблонные функции и конкретизации шаблонов, приоритет отдается первым. В первую очередь рассматриваются варианты точного совпадения типов аргументов, 
то есть варианты не требующие неявных преобразований типов аргументов. Если не существует подходящей нешаблонной функции, то среди конкретизаций шаблонов 
приоритет будут иметь более специализированные шаблоны (более уточненные, менее "шаблонные"). Если выбрана конкретизация шаблона, то проверяется, нет ли 
полной специализации этого шаблона для выведенного типа аргумента конкретизации. Если такая специализация есть, то выбирается она. При этом полная
специализация рассматривается в последнюю очередь, после выбора шаблона. Если брать в учет еще и вариативные шаблоны, то они будут иметь меньший приоритет,
чем шаблоны с фикс. количеством параметром при прочих равных (как менее специализированные)

4.  Инстанцирование шаблонов C++ — это процесс создания конкретной версии шаблона с использованием заданных аргументов типов данных. Особенностью 
инстанцирования является почти полное отсутствие неявных преобразований (связано это с тем, что неявные преобразования проводятся только если есть экзем 
функции, к которой можно неявно преобразовать полученные типы, а шаблон это лишь инструкция компилятору для генерации функции/класса, конкретизация шаблона 
появляется только после процесса инстанцирования). Единственное преобразование типа, которое может произойти при инстанцировании это квалификация: изменение 
константости типа переменной. Причем это преобразование произойдет только в случае передачи переменной по значению, при передачи по ссылке никаких неявных 
преобразований происходить не будет.

5. Специализация шаблона позволяет определить шаблонные классы/функции для конкретного набора параметров шаблона. При полной специализации шаблона указываются 
значения для всех параметров шаблона. И тогда для указанного набора типов компилятор будет использовать специализацию шаблона, а не создавать класс на основе 
шаблона. При частичной специализации шаблона указываются лишь некоторые из параметров шаблона. Эта фишка позволяет, например, реализовать функцию/класс другим
способом для конкретного набора параметров шаблона, при этом для остальных наборов параметров будет использована обычная версия шаблона.